"""
Pyrl Lark Parser Module
Parses Pyrl source code using Lark parser with grammar-based parsing.
Enhanced: Detailed error reporting with line numbers, context, and visual markers.

Generated by GLN-5 model from z.ai
"""
from typing import List, Optional, Any, Dict, Union
from dataclasses import dataclass, field
from lark import Lark, Transformer, Token, Tree
from lark.indenter import Indenter
from lark.exceptions import UnexpectedToken, UnexpectedInput, GrammarError


# ===========================================
# Grammar Definition
# ===========================================

# ===========================================
# Pyrl Grammar - Generated by GLN-5 from z.ai
# ===========================================
GRAMMAR = r"""
# Pyrl Language Grammar
# A hybrid Python-Perl language with sigil-based variables
# Generated by GLN-5 model from z.ai

start: (_NL | statement)*

statement: simple_stmt _NL?
         | compound_stmt

simple_stmt: return_statement
           | assignment
           | print_statement
           | assertion_statement
           | expression_statement
           | func_var_definition

// Special case: &name(...) = { } or &name(...): indented body
// This needs to be simple_stmt to avoid conflict with expression_statement
func_var_definition: FUNC_VAR "(" [arg_list] ")" "=" block
                  | FUNC_VAR "(" [arg_list] ")" ":" _NL INDENT statement+ DEDENT

assertion_statement: ASSERT expression comparison_op expression
                   | ASSERT expression

comparison_op: COMP_OP

expression_statement: expression

compound_stmt: function_definition
             | class_definition
             | conditional
             | loop
             | test_block
             | vue_component_gen

// Function definitions - only with "def" keyword
function_definition: DEF IDENT "(" [arg_list] ")" ":" _NL INDENT (_NL | statement)+ DEDENT

// Block syntax for anonymous functions
// Statements separated by newlines or semicolons
block: "{" [block_stmt (";"? block_stmt)* ";"?] "}"
block_stmt: print_statement
          | return_statement
          | assignment
          | block_if
          | block_while
          | block_for
          | expression_statement
          | conditional
          | loop

// Control flow inside blocks (no indentation)
block_if: IF expression "{" [block_stmt (";"? block_stmt)* ";"?] "}" [ELSE "{" [block_stmt (";"? block_stmt)* ";"?] "}"]
block_while: WHILE expression "{" [block_stmt (";"? block_stmt)* ";"?] "}"
block_for: FOR SCALAR_VAR IN expression "{" [block_stmt (";"? block_stmt)* ";"?] "}"

// OOP: Class definition - supports both { } and : with indentation
class_definition: CLASS IDENT [EXTENDS IDENT] "{" class_member* "}"
                | CLASS IDENT [EXTENDS IDENT] ":" _NL INDENT (_NL | class_member_indented)+ DEDENT

class_member: method_def
            | property_def

class_member_indented: method_def_indented
                     | property_def

// Method definitions
method_def: METHOD IDENT "(" [arg_list] ")" "=" block
          | INIT "(" [arg_list] ")" "=" block

// Method with indentation
method_def_indented: DEF IDENT "(" [arg_list] ")" ":" _NL INDENT (_NL | statement)+ DEDENT
                   | INIT "(" [arg_list] ")" ":" _NL INDENT (_NL | statement)+ DEDENT

// Property definition
property_def: PROP IDENT ["=" expression]

assignment: assign_target "=" expression

assign_target: SCALAR_VAR
             | ARRAY_VAR
             | HASH_VAR
             | FUNC_VAR
             | index_access
             | attribute_access

?expression: or_expr

?or_expr: and_expr (OR and_expr)*

?and_expr: comparison_expr (AND comparison_expr)*

?comparison_expr: additive_expr ((COMP_OP | IN) additive_expr)*

additive_expr: multiplicative_expr (ADD_OP multiplicative_expr)*

multiplicative_expr: power_expr (MUL_OP power_expr)*

power_expr: unary_expr (POW_OP unary_expr)*

?unary_expr: NOT unary_expr
           | NOT_OP unary_expr
           | ADD_OP unary_expr
           | primary_expr

?primary_expr: literal
             | "(" expression ")"
             | regex_literal
             | function_call
             | method_call
             | index_access
             | hash_access_brace
             | attribute_access
             | var_ref
             | block_expr

// Block expression - higher priority than hash_literal
block_expr.2: block

// Hash access with braces (Perl-style): $hash{key}
hash_access_brace.3: primary_expr "{" (STRING | IDENT) "}"

// Attribute access: $obj.attr
attribute_access: primary_expr "." IDENT

// FIXED: Added IDENT to support built-in functions (str, len, int, etc.)
// Added TEST to allow test() as a function call
?var_ref: SCALAR_VAR
        | ARRAY_VAR
        | HASH_VAR
        | FUNC_VAR
        | IDENT
        | TEST

// Index access uses [] brackets for both arrays and hashes (Python-style)
// @array[0] - array index access
// %hash["key"] - hash key access
index_access: primary_expr "[" expression "]"

// Legacy: hash_access and array_access are now unified as index_access

literal: STRING | NUMBER | BOOLEAN | NONE | hash_literal | array_literal

// Hash literal - supports multi-line  
// Priority .1 to give block_expr priority when ambiguous
hash_literal.1: "{" [_NL* hash_item ("," _NL* hash_item)* _NL*] [","] "}"
hash_item: (STRING | IDENT) ":" expression

// Array literal - supports multi-line
array_literal: "[" [_NL* expression ("," _NL* expression)* _NL*] [","] "]"

regex_literal: "r" STRING

conditional: IF expression ":" _NL INDENT (_NL | statement)+ DEDENT else_clause?
else_clause: ELIF expression ":" _NL INDENT (_NL | statement)+ DEDENT else_clause?
           | ELSE ":" _NL INDENT (_NL | statement)+ DEDENT

loop: FOR SCALAR_VAR IN expression ":" _NL INDENT (_NL | statement)+ DEDENT
    | WHILE expression ":" _NL INDENT (_NL | statement)+ DEDENT

test_block: TEST STRING ":" _NL INDENT (_NL | statement)+ DEDENT

print_statement: PRINT "(" [arg_list] ")"

vue_component_gen: VUE STRING ":" _NL INDENT vue_property+ DEDENT
vue_property: IDENT ":" expression _NL

function_call: primary_expr "(" [arg_list] ")"

// Method call on object: $obj.method(args)
method_call: primary_expr "." IDENT "(" [arg_list] ")"

arg_list: expression ("," expression)*

return_statement: RETURN expression?

// ===========================================
// Variable Types with Sigils
// ===========================================
// $ - Scalar variables (single values)
// @ - Array variables (lists)
// % - Hash variables (dictionaries)
// & - Function variables (references)
SCALAR_VAR: "$" IDENT
ARRAY_VAR: "@" IDENT
HASH_VAR: "%" IDENT
FUNC_VAR: "&" IDENT

// FIXED: BOOLEAN and NONE before IDENT to prevent misidentification
BOOLEAN: "True" | "False" | "true" | "false"
NONE: "None" | "none" | "null"

// Keywords - must be before IDENT to have priority
AND: "and"
OR: "or"
NOT: "not"
IN: "in"
CLASS: "class"
EXTENDS: "extends"
METHOD: "method"
INIT: "init"
PROP: "prop"
TEST: "test"
PRINT: "print"
RETURN: "return"
ASSERT: "assert"
FOR: "for"
WHILE: "while"
IF: "if"
ELSE: "else"
ELIF: "elif"
DEF: "def"
VUE: "vue"

// IDENT last (least specific)
IDENT: /[a-zA-Z_][a-zA-Z0-9_]*/

STRING: ESCAPED_STRING
       | SINGLE_QUOTED_STRING
       | TRIPLE_QUOTED_STRING

ESCAPED_STRING: /"(?:[^"\\]|\\.)*"/
SINGLE_QUOTED_STRING: /'[^']*'/
TRIPLE_QUOTED_STRING.2: /\"\"\"(.|\n)*?\"\"\"/


NUMBER: INT | FLOAT
INT: /\d+/
FLOAT: /\d+\.\d*/

// ===========================================
// Operators - FIXED: Order matters! Longer operators first
// ===========================================
COMP_OP: "==" | "!=" | "<=" | ">=" | "=~" | "!~" | "<" | ">"
ADD_OP: "+" | "-"
MUL_OP: "//" | "*" | "/" | "%"
POW_OP: "**" | "^"
NOT_OP: "!"

// Whitespace (inline)
WS_INLINE: /[\t ]+/

%ignore WS_INLINE

// Proper regex syntax for newlines (no broken \r?\n)
_NL: /(?:\r?\n[\t ]*)+/

// Comments - only # style to avoid conflict with // operator
COMMENT: /#[^\n]*/

%ignore WS_INLINE
%ignore COMMENT
%declare INDENT DEDENT
"""


# ===========================================
# AST Node Classes
# ===========================================

@dataclass
class Program:
    """Root AST node containing all statements."""
    statements: List[Any] = field(default_factory=list)


@dataclass
class ScalarVar:
    """Scalar variable ($name)."""
    name: str


@dataclass
class ArrayVar:
    """Array variable (@name)."""
    name: str


@dataclass
class HashVar:
    """Hash variable (%name)."""
    name: str


@dataclass
class FuncVar:
    """Function variable (&name)."""
    name: str


@dataclass(frozen=True)
class IdentRef:
    """Identifier reference (for built-in functions)."""
    name: str


@dataclass
class NumberLiteral:
    """Numeric literal."""
    value: Union[int, float]


@dataclass
class StringLiteral:
    """String literal."""
    value: str


@dataclass
class BooleanLiteral:
    """Boolean literal."""
    value: bool


@dataclass
class NoneLiteral:
    """None/null literal."""
    pass


@dataclass
class ArrayLiteral:
    """Array literal [a, b, c]."""
    elements: List[Any] = field(default_factory=list)


@dataclass
class HashLiteral:
    """Hash literal {key: value}."""
    pairs: Dict[str, Any] = field(default_factory=dict)


@dataclass
class RegexLiteral:
    """Regex literal r"pattern"."""
    pattern: str


@dataclass
class BinaryOp:
    """Binary operation."""
    left: Any
    operator: str
    right: Any


@dataclass
class UnaryOp:
    """Unary operation."""
    operator: str
    operand: Any


@dataclass
class Assignment:
    """Variable assignment."""
    target: Any
    value: Any


@dataclass
class HashAccess:
    """Hash access with {} brackets: %hash{"key"}"""
    obj: Any
    key: Any


@dataclass
class ArrayAccess:
    """Array access with [] brackets: @array[0]"""
    obj: Any
    index: Any


@dataclass
class AttributeAccess:
    """Attribute access: $obj.attr"""
    obj: Any
    attr: str


@dataclass
class FunctionCall:
    """Function call expression."""
    name: str
    args: List[Any] = field(default_factory=list)


@dataclass
class FunctionDef:
    """Function definition."""
    name: str
    params: List[str] = field(default_factory=list)
    body: List[Any] = field(default_factory=list)


@dataclass
class IfStatement:
    """If/elif/else statement."""
    condition: Any
    then_body: List[Any] = field(default_factory=list)
    elif_clauses: List[tuple] = field(default_factory=list)
    else_body: Optional[List[Any]] = None


@dataclass
class ForLoop:
    """For loop statement."""
    var: str
    iterable: Any
    body: List[Any] = field(default_factory=list)


@dataclass
class WhileLoop:
    """While loop statement."""
    condition: Any
    body: List[Any] = field(default_factory=list)


@dataclass
class ReturnStatement:
    """Return statement."""
    value: Optional[Any] = None


@dataclass
class PrintStatement:
    """Print statement."""
    values: List[Any] = field(default_factory=list)


@dataclass
class AssertStatement:
    """Assert statement."""
    left: Any
    operator: Optional[str] = None
    right: Optional[Any] = None


@dataclass
class TestBlock:
    """Test block."""
    name: Optional[str] = None
    body: List[Any] = field(default_factory=list)


@dataclass
class VueComponent:
    """Vue component generation."""
    name: str
    properties: Dict[str, Any] = field(default_factory=dict)


# ===========================================
# OOP AST Nodes
# ===========================================

@dataclass
class Block:
    """Block of statements { stmt1; stmt2; ... }"""
    statements: List[Any] = field(default_factory=list)


@dataclass
class AnonymousFuncDef:
    """Anonymous function definition: &name($params) = { body }"""
    name: str
    params: List[str] = field(default_factory=list)
    body: List[Any] = field(default_factory=list)


@dataclass
class ClassDef:
    """Class definition."""
    name: str
    extends: Optional[str] = None
    methods: Dict[str, Any] = field(default_factory=dict)
    properties: Dict[str, Any] = field(default_factory=dict)


@dataclass
class MethodDef:
    """Method definition."""
    name: str  # 'init' for constructor, otherwise method name
    params: List[str] = field(default_factory=list)
    body: List[Any] = field(default_factory=list)


@dataclass
class PropertyDef:
    """Property definition."""
    name: str
    value: Optional[Any] = None


@dataclass
class MethodCall:
    """Method call on object: $obj.method(args)"""
    obj: Any
    method: str
    args: List[Any] = field(default_factory=list)


# ===========================================
# Indenter for Python-like indentation
# ===========================================

class PyrlIndenter(Indenter):
    """Handle Python-like indentation for Lark parser."""

    NL_type = '_NL'
    OPEN_PAREN_types = ['LPAR', 'LSQB', 'LBRACE']
    CLOSE_PAREN_types = ['RPAR', 'RSQB', 'RBRACE']
    INDENT_type = 'INDENT'
    DEDENT_type = 'DEDENT'
    tab_len = 4


# ===========================================
# Error Reporting
# ===========================================

class ParseErrorInfo:
    """Detailed parse error information."""

    def __init__(self, source: str, exception: Exception):
        self.source = source
        self.exception = exception
        self.lines = source.split('\n')  # Proper newline
        self.line_num = 1
        self.col_num = 1
        self.context_lines = 3
        self._parse_exception()

    def _parse_exception(self):
        if isinstance(self.exception, UnexpectedToken):
            self.line_num = getattr(self.exception, 'line', 1)
            self.col_num = getattr(self.exception, 'column', 1)
            self.token = getattr(self.exception, 'token', None)
            self.expected = getattr(self.exception, 'accepts', []) or []
        elif isinstance(self.exception, UnexpectedInput):
            self.line_num = getattr(self.exception, 'line', 1)
            self.col_num = getattr(self.exception, 'column', 1)
            self.token = getattr(self.exception, 'token', None)
            self.expected = []
        else:
            self.token = None
            self.expected = []

    def get_context(self) -> str:
        start_line = max(0, self.line_num - self.context_lines - 1)
        end_line = min(len(self.lines), self.line_num + self.context_lines)
        context = []
        line_num_width = len(str(end_line))
        for i in range(start_line, end_line):
            line_no = i + 1
            line_content = self.lines[i] if i < len(self.lines) else ''
            prefix = f"{line_no:>{line_num_width}} | "
            context.append(f"{prefix}{line_content}")
            if i + 1 == self.line_num:
                marker = ' ' * len(prefix) + ' ' * (self.col_num - 1) + '^' * max(1, len(str(self.token.value)) if self.token else 1)
                context.append(f"\033[91m{marker}\033[0m")
        return '\n'.join(context)  # Proper newline

    def format_expected(self) -> str:
        if not self.expected:
            return "Unknown"
        # Handle both set and list types for expected tokens
        expected_items = list(self.expected) if isinstance(self.expected, (set, frozenset)) else self.expected
        token_map = {
            'SCALAR_VAR': '$variable', 'ARRAY_VAR': '@variable', 'HASH_VAR': '%variable',
            'FUNC_VAR': '&variable', 'IDENT': 'identifier', 'STRING': 'string',
            'NUMBER': 'number', 'BOOLEAN': 'boolean', 'NONE': 'None',
            'LPAR': '(', 'RPAR': ')', 'LSQB': '[', 'RSQB': ']', 'LBRACE': '{', 'RBRACE': '}',
            'COLON': ':', 'COMMA': ',', 'COMP_OP': 'comparison', 'ADD_OP': '+/-',
            'MUL_OP': '*/%', 'IF': 'if', 'ELSE': 'else', 'ELIF': 'elif',
            'FOR': 'for', 'WHILE': 'while', 'DEF': 'def', 'RETURN': 'return',
            'PRINT': 'print', '_NL': 'newline',
        }
        readable = [token_map.get(str(t), str(t)) for t in expected_items[:10]]
        if len(expected_items) > 10:
            readable.append(f"... and {len(expected_items) - 10} more")
        return ', '.join(readable)

    def __str__(self) -> str:
        error_msg = [
            "\033[91m" + "=" * 60 + "\033[0m",
            "\033[91mPARSE ERROR\033[0m",
            "\033[91m" + "=" * 60 + "\033[0m",
            f"\033[93mLocation:\033[0m Line {self.line_num}, Column {self.col_num}",
        ]
        if self.token:
            error_msg.append(f"\033[93mUnexpected token:\033[0m {self.token.value!r} (type: {self.token.type})")
        error_msg.append(f"\033[93mExpected one of:\033[0m {self.format_expected()}")
        error_msg.append("")
        error_msg.append("\033[93mContext:\033[0m")
        error_msg.append(self.get_context())
        error_msg.append("")
        error_msg.append("\033[91m" + "=" * 60 + "\033[0m")
        return '\n'.join(error_msg)


# ===========================================
# AST Transformer
# ===========================================

class PyrlTransformer(Transformer):
    """Transform Lark parse tree into Pyrl AST."""

    def _filter_tokens(self, items):
        return [c for c in items if c is not None and not isinstance(c, Token)]

    def start(self, children):
        statements = []
        for child in children:
            if isinstance(child, list):
                statements.extend(self._filter_tokens(child))
            elif child is not None and not isinstance(child, Token):
                statements.append(child)
        return Program(statements=statements)

    def statement(self, children):
        return children[0] if children and not isinstance(children[0], Token) else None

    def simple_stmt(self, children):
        return children[0] if children and not isinstance(children[0], Token) else None

    def compound_stmt(self, children):
        return children[0] if children and not isinstance(children[0], Token) else None

    def expression_statement(self, children):
        return children[0] if children and not isinstance(children[0], Token) else None

    def SCALAR_VAR(self, t): return ScalarVar(name=t.value[1:])
    def ARRAY_VAR(self, t): return ArrayVar(name=t.value[1:])
    def HASH_VAR(self, t): return HashVar(name=t.value[1:])
    def FUNC_VAR(self, t): return FuncVar(name=t.value[1:])
    def IDENT(self, t): return IdentRef(name=t.value)
    def TEST(self, t): return IdentRef(name=t.value)  # Allow test as function name

    def NUMBER(self, t):
        v = t.value
        return NumberLiteral(value=float(v) if '.' in v or 'e' in v.lower() or 'E' in v else int(v))

    def STRING(self, t):
        v = t.value
        if len(v) >= 2:
            # Triple-quoted string: """..."""
            if v.startswith('"""') and v.endswith('"""'):
                v = v[3:-3]  # Remove triple quotes
                # Don't process escape sequences in triple-quoted strings (raw-like)
            # Regular double-quoted string: "..."
            elif v.startswith('"') and v.endswith('"'):
                v = v[1:-1].replace('\\n', '\n').replace('\\t', '\t').replace('\\r', '\r').replace('\\"', '"').replace('\\\\', '\\')
            # Single-quoted string: '...'
            elif v.startswith("'") and v.endswith("'"):
                v = v[1:-1]
        return StringLiteral(value=v)

    def BOOLEAN(self, t): return BooleanLiteral(value=t.value.lower() == 'true')
    def NONE(self, t): return NoneLiteral()

    def array_literal(self, children):
        return ArrayLiteral(elements=[c for c in children if c is not None and not (isinstance(c, Token) and c.value == ',')])

    def hash_literal(self, children):
        pairs = {}
        for c in children:
            if isinstance(c, tuple) and len(c) == 2:
                key, value = c
                # Convert key to string if it's an AST node
                if isinstance(key, IdentRef):
                    key = key.name
                elif isinstance(key, StringLiteral):
                    key = key.value
                elif isinstance(key, Token):
                    key = key.value
                pairs[key] = value
        return HashLiteral(pairs=pairs)

    def hash_item(self, children):
        if len(children) < 2: return None
        key = children[0]
        if isinstance(key, Token):
            key = key.value
            if (key.startswith('"') and key.endswith('"')) or (key.startswith("'") and key.endswith("'")):
                key = key[1:-1]
        # Handle IdentRef for hash keys
        elif isinstance(key, IdentRef):
            key = key.name
        # Handle StringLiteral for hash keys
        elif isinstance(key, StringLiteral):
            key = key.value
        return (key, children[1])

    def regex_literal(self, children):
        p = children[0]
        return RegexLiteral(pattern=p.value if isinstance(p, StringLiteral) else str(p))

    def or_expr(self, children): return self._build_binary_ops(children, 'or')
    def and_expr(self, children): return self._build_binary_ops(children, 'and')
    def comparison_expr(self, children): return self._build_binary_ops(children, None)
    def additive_expr(self, children): return self._build_binary_ops(children, None)
    def multiplicative_expr(self, children): return self._build_binary_ops(children, None)
    def power_expr(self, children): return self._build_binary_ops(children, None)

    def _build_binary_ops(self, children, specific_op=None):
        if len(children) == 1: return children[0]
        result = children[0]
        for i in range(1, len(children), 2):
            if isinstance(children[i], Token):
                op = children[i].value
                if specific_op is None or op == specific_op:
                    result = BinaryOp(left=result, operator=op, right=children[i + 1])
        return result

    def unary_expr(self, children):
        if len(children) == 1: return children[0]
        if isinstance(children[0], Token):
            return UnaryOp(operator=children[0].value, operand=children[1])
        return children[0]

    def primary_expr(self, children): return children[0] if children else None
    def literal(self, children): return children[0] if children else None

    def index_access(self, children):
        """Unified index access for both arrays and hashes (Python-style [])."""
        return ArrayAccess(obj=children[0], index=children[1]) if len(children) >= 2 else (children[0] if children else None)

    # Legacy methods - kept for backward compatibility
    def hash_access(self, children):
        return HashAccess(obj=children[0], key=children[1]) if len(children) >= 2 else (children[0] if children else None)

    def array_access(self, children):
        return ArrayAccess(obj=children[0], index=children[1]) if len(children) >= 2 else (children[0] if children else None)

    def attribute_access(self, children):
        """Transform attribute access: $obj.attr"""
        if len(children) >= 2:
            obj = children[0]
            attr = children[1].value if isinstance(children[1], Token) else str(children[1])
            return AttributeAccess(obj=obj, attr=attr)
        return children[0] if children else None

    def hash_access_brace(self, children):
        """Transform Perl-style hash access: $hash{key}"""
        if len(children) >= 2:
            obj = children[0]
            key_token = children[1]
            if isinstance(key_token, Token):
                key = StringLiteral(value=key_token.value) if key_token.type == 'STRING' else StringLiteral(value=key_token.value)
            elif isinstance(key_token, StringLiteral):
                key = key_token
            else:
                key = StringLiteral(value=str(key_token))
            return ArrayAccess(obj=obj, index=key)  # Use ArrayAccess for [] style access
        return children[0] if children else None

    def assign_target(self, children): return children[0] if children else None

    def assignment(self, children):
        return Assignment(target=children[0], value=children[1]) if len(children) >= 2 else None

    # Handle IdentRef for function names
    def function_definition(self, children):
        """Transform function definition."""
        name = None
        params = []
        body = []
        
        i = 0
        # Skip 'def' or '&' token
        if i < len(children) and isinstance(children[i], Token) and children[i].value in ('def', '&'):
            i += 1
        
        # Get function name
        if i < len(children):
            if isinstance(children[i], FuncVar):
                name = children[i].name
                i += 1
            elif isinstance(children[i], Token) and children[i].type == 'IDENT':
                name = children[i].value
                i += 1
            elif isinstance(children[i], IdentRef):
                name = children[i].name
                i += 1
        
        # Skip tokens until we find arg_list or params
        while i < len(children):
            child = children[i]
            if isinstance(child, list):
                # This could be arg_list (params) or body
                # Check if this is a parameter list
                is_param_list = all(isinstance(p, (ScalarVar, HashVar, ArrayVar, FuncVar)) for p in child if p is not None)
                if is_param_list:
                    # Extract parameter names with appropriate sigils
                    for p in child:
                        if isinstance(p, ScalarVar):
                            params.append(('$' + p.name, 'scalar'))
                        elif isinstance(p, HashVar):
                            params.append(('%' + p.name, 'hash'))
                        elif isinstance(p, ArrayVar):
                            params.append(('@' + p.name, 'array'))
                        elif isinstance(p, FuncVar):
                            params.append(('&' + p.name, 'func'))
                else:
                    # This could be body statements
                    body = self._filter_tokens(child)
                i += 1
            elif isinstance(child, Token):
                i += 1
            elif child is None:
                i += 1
            else:
                # Could be a statement (body)
                body.append(child)
                i += 1
        
        return FunctionDef(name=name or '<anonymous>', params=params, body=body)

    def function_call(self, children):
        if not children: return None
        name_node = children[0]
        if isinstance(name_node, (FuncVar, ScalarVar, ArrayVar, HashVar)):
            name = name_node.name
        elif isinstance(name_node, IdentRef):
            name = name_node.name
        elif isinstance(name_node, Token) and name_node.type == 'IDENT':
            name = name_node.value
        elif hasattr(name_node, 'name'):
            name = name_node.name
        else:
            name = str(name_node)
        args = []
        for child in children[1:]:
            if isinstance(child, list):
                args.extend([c for c in child if c is not None and not (isinstance(c, Token) and c.value == ',')])
            elif child is not None and not isinstance(child, Token):
                args.append(child)
        return FunctionCall(name=name, args=args)

    def arg_list(self, children):
        return [c for c in children if c is not None and not (isinstance(c, Token) and c.value == ',')]

    def conditional(self, children):
        """Transform if/elif/else statement."""
        condition = None
        then_body = []
        elif_clauses = []
        else_body = None
        current_elif_cond = None

        # Process children
        # Structure: condition, INDENT, statements..., DEDENT, [else_clause]
        # else_clause may contain: 'elif', condition, INDENT, statements..., DEDENT
        # or: 'else', INDENT, statements..., DEDENT

        i = 0
        # Skip 'if' token if present
        while i < len(children) and isinstance(children[i], Token) and children[i].value == 'if':
            i += 1

        # Get condition
        if i < len(children) and not isinstance(children[i], Token):
            condition = children[i]
            i += 1

        # Skip INDENT token
        while i < len(children) and isinstance(children[i], Token) and children[i].type == 'INDENT':
            i += 1

        # Collect then_body statements until DEDENT or next clause
        while i < len(children):
            child = children[i]
            if isinstance(child, Token):
                if child.type == 'DEDENT':
                    i += 1
                    break
                elif child.value in ('elif', 'else'):
                    break
                i += 1
            elif isinstance(child, list):
                then_body.extend(self._filter_tokens(child))
                i += 1
            else:
                then_body.append(child)
                i += 1

        # Process elif/else clauses
        while i < len(children):
            child = children[i]

            if isinstance(child, Token) and child.value == 'elif':
                i += 1
                # Get elif condition
                elif_cond = None
                if i < len(children) and not isinstance(children[i], Token):
                    elif_cond = children[i]
                    i += 1

                # Skip INDENT
                while i < len(children) and isinstance(children[i], Token) and children[i].type == 'INDENT':
                    i += 1

                # Collect elif body
                elif_body = []
                while i < len(children):
                    c = children[i]
                    if isinstance(c, Token):
                        if c.type == 'DEDENT':
                            i += 1
                            break
                        elif c.value in ('elif', 'else'):
                            break
                        i += 1
                    elif isinstance(c, list):
                        elif_body.extend(self._filter_tokens(c))
                        i += 1
                    else:
                        elif_body.append(c)
                        i += 1

                if elif_cond:
                    elif_clauses.append((elif_cond, elif_body))

            elif isinstance(child, Token) and child.value == 'else':
                i += 1
                # Skip INDENT
                while i < len(children) and isinstance(children[i], Token) and children[i].type == 'INDENT':
                    i += 1

                # Collect else body
                else_body = []
                while i < len(children):
                    c = children[i]
                    if isinstance(c, Token):
                        if c.type == 'DEDENT':
                            i += 1
                            break
                        i += 1
                    elif isinstance(c, list):
                        else_body.extend(self._filter_tokens(c))
                        i += 1
                    else:
                        else_body.append(c)
                        i += 1
            elif isinstance(child, list):
                # Could be else_clause nested data
                # Structure for elif: [condition, INDENT, statements..., DEDENT, else_clause?]
                # Structure for else: [INDENT, statements..., DEDENT]
                if len(child) >= 1:
                    # Check if first item is a Token
                    first_item = child[0] if child else None
                    
                    # If it starts with INDENT, it's an else body
                    if isinstance(first_item, Token) and first_item.type == 'INDENT':
                        else_body = []
                        for item in child[1:]:  # Skip INDENT
                            if isinstance(item, Token) and item.type == 'DEDENT':
                                break
                            elif isinstance(item, list):
                                else_body.extend(self._filter_tokens(item))
                            elif not isinstance(item, Token):
                                else_body.append(item)
                    elif first_item is not None and not isinstance(first_item, Token):
                        # This is an elif clause: [condition, INDENT, body..., DEDENT, else_clause?]
                        elif_cond = first_item
                        elif_body = []
                        
                        # Skip INDENT and collect body
                        j = 1
                        while j < len(child) and isinstance(child[j], Token) and child[j].type == 'INDENT':
                            j += 1
                        
                        # Collect elif body until DEDENT or end
                        while j < len(child):
                            item = child[j]
                            if isinstance(item, Token) and item.type == 'DEDENT':
                                j += 1
                                break
                            elif isinstance(item, list):
                                elif_body.extend(self._filter_tokens(item))
                            elif not isinstance(item, Token):
                                elif_body.append(item)
                            j += 1
                        
                        if elif_cond:
                            elif_clauses.append((elif_cond, elif_body))
                        
                        # Check if there's an else clause remaining
                        if j < len(child) and isinstance(child[j], list):
                            else_list = child[j]
                            if len(else_list) >= 1 and isinstance(else_list[0], Token) and else_list[0].type == 'INDENT':
                                else_body = []
                                for item in else_list[1:]:
                                    if isinstance(item, Token) and item.type == 'DEDENT':
                                        break
                                    elif isinstance(item, list):
                                        else_body.extend(self._filter_tokens(item))
                                    elif not isinstance(item, Token):
                                        else_body.append(item)
                    else:
                        # Try to extract elif/else from nested structure
                        for item in child:
                            if isinstance(item, tuple) and len(item) == 2:
                                elif_clauses.append((item[0], self._filter_tokens(item[1]) if isinstance(item[1], list) else [item[1]]))
                            elif isinstance(item, list):
                                else_body = self._filter_tokens(item)
                i += 1
            else:
                i += 1

        return IfStatement(condition=condition, then_body=then_body, elif_clauses=elif_clauses, else_body=else_body)

    def else_clause(self, children): return children if children else None

    def loop(self, children):
        """Transform loop statement (for or while)."""
        if not children:
            return None

        # Filter out None values
        children = [c for c in children if c is not None]

        # For loop: first child is ScalarVar (loop variable)
        # While loop: first child is expression (condition)
        if children and isinstance(children[0], ScalarVar):
            # This is a for loop: for $var in iterable: body
            var = children[0].name
            iterable = None
            body = []

            # Second child should be the iterable expression
            if len(children) > 1:
                iterable = children[1]

            # Remaining children are body statements
            for c in children[2:]:
                if isinstance(c, list):
                    body.extend(self._filter_tokens(c))
                elif not isinstance(c, Token):
                    body.append(c)

            return ForLoop(var=var or '_i', iterable=iterable, body=body)
        else:
            # This is a while loop: while condition: body
            condition = None
            body = []

            if children:
                condition = children[0]

            # Remaining children are body statements
            for c in children[1:]:
                if isinstance(c, list):
                    body.extend(self._filter_tokens(c))
                elif not isinstance(c, Token):
                    body.append(c)

            return WhileLoop(condition=condition, body=body)

    def return_statement(self, children):
        return ReturnStatement(value=children[0] if children and children[0] is not None else None)

    def print_statement(self, children):
        """Transform print statement with multiple arguments."""
        values = []
        for child in children:
            if isinstance(child, list):
                values.extend([c for c in child if c is not None])
            elif child is not None:
                values.append(child)
        return PrintStatement(values=values)

    def assertion_statement(self, children):
        if len(children) == 1:
            return AssertStatement(left=children[0], operator=None, right=None)
        elif len(children) >= 3:
            op = children[1].value if isinstance(children[1], Token) else str(children[1])
            return AssertStatement(left=children[0], operator=op, right=children[2])
        return AssertStatement(left=children[0] if children else None, operator=None, right=None)

    def comparison_op(self, children): return children[0] if children else None

    def test_block(self, children):
        name = None
        body = []
        for child in children:
            if isinstance(child, StringLiteral): name = child.value
            elif isinstance(child, list): body = self._filter_tokens(child)
        return TestBlock(name=name, body=body)

    def vue_component_gen(self, children):
        if not children: return None
        name = children[0].value if isinstance(children[0], StringLiteral) else str(children[0])
        properties = {}
        for child in children[1:]:
            if isinstance(child, tuple) and len(child) == 2:
                properties[child[0]] = child[1]
        return VueComponent(name=name, properties=properties)

    def vue_property(self, children):
        if len(children) >= 2:
            key = children[0].value if isinstance(children[0], Token) else str(children[0])
            return (key, children[1])
        return None

    # ===========================================
    # OOP and Anonymous Functions Transformers
    # ===========================================

    def block(self, children):
        """Transform block { stmts } into Block node."""
        statements = []
        for child in children:
            if isinstance(child, list):
                statements.extend(self._filter_tokens(child))
            elif isinstance(child, Block):
                statements.extend(child.statements)
            elif child is not None and not isinstance(child, Token):
                statements.append(child)
        return Block(statements=statements)

    def block_expr(self, children):
        """Transform block_expr - returns the Block."""
        return children[0] if children else None

    def block_stmts(self, children):
        """Transform block_stmts into list of statements."""
        return [c for c in children if c is not None and not isinstance(c, Token)]

    def block_stmt(self, children):
        """Transform block_stmt."""
        return children[0] if children else None

    def block_sep(self, children):
        """Block separator (newlines or semicolons) - ignore in AST."""
        return None

    def block_if(self, children):
        """Transform block if statement."""
        condition = None
        then_body = []
        else_body = None

        for child in children:
            if isinstance(child, Token):
                continue
            elif condition is None:
                condition = child
            elif isinstance(child, Block):
                if not then_body:
                    then_body = child.statements
                else:
                    else_body = child.statements

        return IfStatement(condition=condition, then_body=then_body, else_body=else_body)

    def block_while(self, children):
        """Transform block while statement."""
        condition = None
        body = []

        for child in children:
            if isinstance(child, Token):
                continue
            elif condition is None:
                condition = child
            elif isinstance(child, Block):
                body = child.statements

        return WhileLoop(condition=condition, body=body)

    def block_for(self, children):
        """Transform block for statement."""
        var = None
        iterable = None
        body = []

        for child in children:
            if isinstance(child, Token):
                continue
            elif isinstance(child, ScalarVar):
                var = child.name
            elif iterable is None:
                iterable = child
            elif isinstance(child, Block):
                body = child.statements

        return ForLoop(var=var or '_i', iterable=iterable, body=body)

    def func_var_definition(self, children):
        """Transform function variable definition: &name($params) = { body } or &name($params): indented body"""
        name = None
        params = []
        body = []

        for child in children:
            if isinstance(child, FuncVar):
                name = child.name
            elif isinstance(child, list):
                # Could be params or body
                if all(isinstance(p, ScalarVar) for p in child if p is not None):
                    params = [p.name for p in child if isinstance(p, ScalarVar)]
                else:
                    body.extend(self._filter_tokens(child))
            elif isinstance(child, Block):
                body.extend(child.statements)
            elif isinstance(child, Token):
                continue
            elif child is not None:
                # Check if it's a param list
                if isinstance(child, ScalarVar):
                    params.append(child.name)
                else:
                    # It's a body statement
                    body.append(child)

        return AnonymousFuncDef(name=name or '<anonymous>', params=params, body=body)

    # Keep for backward compatibility
    def anonymous_func_def(self, children):
        return self.func_var_definition(children)

    def class_definition(self, children):
        """Transform class definition."""
        name = None
        extends = None
        methods = {}
        properties = {}

        for child in children:
            if isinstance(child, Token):
                if child.type == 'IDENT' and name is None:
                    name = child.value
                elif child.type == 'EXTENDS':
                    continue
            elif isinstance(child, IdentRef):
                if name is None:
                    name = child.name
                else:
                    extends = child.name
            elif isinstance(child, str):
                # Could be class name or parent class name
                if name is None:
                    name = child
                elif extends is None:
                    extends = child
            elif isinstance(child, MethodDef):
                methods[child.name] = child
            elif isinstance(child, PropertyDef):
                properties[child.name] = child
            elif isinstance(child, dict):
                # Could be methods or properties dict
                if child:
                    first_value = list(child.values())[0]
                    if isinstance(first_value, MethodDef):
                        methods.update(child)
                    else:
                        properties.update(child)

        return ClassDef(name=name or '<anonymous>', extends=extends, methods=methods, properties=properties)

    def class_body(self, children):
        """Transform class body."""
        return [c for c in children if c is not None and not isinstance(c, Token)]

    def class_member(self, children):
        """Transform class member."""
        return children[0] if children else None

    def method_def(self, children):
        """Transform method definition."""
        name = None
        params = []
        body = []

        for child in children:
            if isinstance(child, Token):
                if child.type in ('IDENT', 'INIT', 'METHOD'):
                    if child.value in ('method', 'init'):
                        continue
                    name = child.value
            elif isinstance(child, IdentRef):
                name = child.name
            elif isinstance(child, list):
                # Check if this is a param list
                is_param_list = all(isinstance(p, (ScalarVar, FuncVar)) for p in child if p is not None)
                if is_param_list:
                    for p in child:
                        if isinstance(p, ScalarVar):
                            params.append(('$' + p.name, 'scalar'))
                        elif isinstance(p, FuncVar):
                            params.append(('&' + p.name, 'func'))
                else:
                    body = self._filter_tokens(child)
            elif isinstance(child, Block):
                body = child.statements
            elif isinstance(child, ScalarVar):
                params.append(('$' + child.name, 'scalar'))
            elif isinstance(child, FuncVar):
                params.append(('&' + child.name, 'func'))
            elif child is not None and not isinstance(child, Token):
                body.append(child)

        return MethodDef(name=name or 'init', params=params, body=body)

    def property_def(self, children):
        """Transform property definition."""
        name = None
        value = None

        for child in children:
            if isinstance(child, Token):
                if child.type == 'IDENT':
                    name = child.value
                elif child.type == 'PROP':
                    continue
            elif isinstance(child, IdentRef):
                name = child.name
            elif child is not None:
                value = child

        return PropertyDef(name=name or '', value=value)

    def class_member_indented(self, children):
        """Transform class member in indented class body."""
        return children[0] if children else None

    def method_def_indented(self, children):
        """Transform method definition with indentation."""
        name = None
        params = []
        body = []

        for child in children:
            if isinstance(child, Token):
                if child.type in ('IDENT', 'INIT'):
                    if child.value in ('init', '__init__'):
                        name = 'init'
                    elif name is None:
                        name = child.value
            elif isinstance(child, IdentRef):
                name = child.name
            elif isinstance(child, list):
                # Check if this is a param list
                is_param_list = all(isinstance(p, (ScalarVar, FuncVar, HashVar, ArrayVar)) for p in child if p is not None)
                if is_param_list:
                    for p in child:
                        if isinstance(p, ScalarVar):
                            params.append(('$' + p.name, 'scalar'))
                        elif isinstance(p, FuncVar):
                            params.append(('&' + p.name, 'func'))
                        elif isinstance(p, HashVar):
                            params.append(('%' + p.name, 'hash'))
                        elif isinstance(p, ArrayVar):
                            params.append(('@' + p.name, 'array'))
                else:
                    body = self._filter_tokens(child)
            elif isinstance(child, Block):
                body = child.statements
            elif isinstance(child, ScalarVar):
                params.append(('$' + child.name, 'scalar'))
            elif isinstance(child, FuncVar):
                params.append(('&' + child.name, 'func'))
            elif isinstance(child, HashVar):
                params.append(('%' + child.name, 'hash'))
            elif isinstance(child, ArrayVar):
                params.append(('@' + child.name, 'array'))
            elif child is not None and not isinstance(child, Token):
                body.append(child)

        return MethodDef(name=name or 'init', params=params, body=body)

    def method_call(self, children):
        """Transform method call: $obj.method(args)"""
        obj = None
        method = None
        args = []

        for child in children:
            if isinstance(child, Token):
                if child.type == 'IDENT':
                    method = child.value
            elif isinstance(child, IdentRef):
                method = child.name
            elif isinstance(child, list):
                args = [c for c in child if c is not None and not isinstance(c, Token)]
            elif child is not None:
                if obj is None:
                    obj = child
                elif method is None:
                    method = child

        return MethodCall(obj=obj, method=method or '', args=args)


# ===========================================
# Parser Class
# ===========================================

class PyrlLarkParser:
    """Lark-based parser for Pyrl language."""

    def __init__(self, debug: bool = False):
        self.debug = debug
        self.parser = Lark(
            GRAMMAR,
            parser='lalr',
            transformer=PyrlTransformer(),
            postlex=PyrlIndenter(),
            start='start',
            debug=debug
        )

    def parse(self, source: str) -> Program:
        try:
            return self.parser.parse(source)
        except UnexpectedToken as e:
            error_info = ParseErrorInfo(source, e)
            if self.debug:
                print(f"\n\033[93mDebug info:\033[0m")
                print(f"  Token type: {e.token.type}")
                print(f"  Token value: {e.token.value!r}")
                print(f"  Line: {e.line}, Column: {e.column}")
                print(f"  Expected tokens: {e.accepts}")
            raise SyntaxError(str(error_info))
        except UnexpectedInput as e:
            raise SyntaxError(str(ParseErrorInfo(source, e)))
        except GrammarError as e:
            raise SyntaxError(f"Grammar error: {e}")
        except Exception as e:
            raise SyntaxError(f"Parse error: {e}")

    def parse_file(self, filepath: str) -> Program:
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                return self.parse(f.read())
        except FileNotFoundError:
            raise SyntaxError(f"File not found: {filepath}")
        except UnicodeDecodeError as e:
            raise SyntaxError(f"Encoding error in file {filepath}: {e}")


# ===========================================
# Convenience Functions
# ===========================================

_parser = None

def get_parser(debug: bool = False) -> PyrlLarkParser:
    global _parser
    if _parser is None or debug:
        _parser = PyrlLarkParser(debug=debug)
    return _parser

def parse_lark(source: str, debug: bool = False) -> Program:
    return get_parser(debug).parse(source)

def parse_file_lark(filepath: str, debug: bool = False) -> Program:
    return get_parser(debug).parse_file(filepath)


# ===========================================
# Tree Printer for Debugging
# ===========================================

def print_ast(node, indent: int = 0) -> None:
    pfx = "  " * indent
    if isinstance(node, Program):
        print(f"{pfx}Program:")
        for stmt in node.statements: print_ast(stmt, indent + 1)
    elif isinstance(node, ScalarVar): print(f"{pfx}ScalarVar: ${node.name}")
    elif isinstance(node, ArrayVar): print(f"{pfx}ArrayVar: @{node.name}")
    elif isinstance(node, HashVar): print(f"{pfx}HashVar: %{node.name}")
    elif isinstance(node, FuncVar): print(f"{pfx}FuncVar: &{node.name}")
    elif isinstance(node, IdentRef): print(f"{pfx}IdentRef: {node.name}")
    elif isinstance(node, NumberLiteral): print(f"{pfx}Number: {node.value}")
    elif isinstance(node, StringLiteral): print(f"{pfx}String: {repr(node.value)}")
    elif isinstance(node, BooleanLiteral): print(f"{pfx}Boolean: {node.value}")
    elif isinstance(node, NoneLiteral): print(f"{pfx}None")
    elif isinstance(node, ArrayLiteral):
        print(f"{pfx}Array:")
        for elem in node.elements: print_ast(elem, indent + 1)
    elif isinstance(node, HashLiteral):
        print(f"{pfx}Hash:")
        for k, v in node.pairs.items(): print(f"{pfx}  {k}:"); print_ast(v, indent + 2)
    elif isinstance(node, BinaryOp):
        print(f"{pfx}BinaryOp: {node.operator}"); print_ast(node.left, indent + 2); print_ast(node.right, indent + 2)
    elif isinstance(node, UnaryOp): print(f"{pfx}UnaryOp: {node.operator}"); print_ast(node.operand, indent + 1)
    elif isinstance(node, Assignment):
        print(f"{pfx}Assignment:"); print_ast(node.target, indent + 2); print_ast(node.value, indent + 2)
    elif isinstance(node, HashAccess): print(f"{pfx}HashAccess {{}}:"); print_ast(node.obj, indent + 2); print_ast(node.key, indent + 2)
    elif isinstance(node, ArrayAccess): print(f"{pfx}ArrayAccess []:"); print_ast(node.obj, indent + 2); print_ast(node.index, indent + 2)
    elif isinstance(node, FunctionCall):
        print(f"{pfx}FunctionCall: {node.name}")
        for arg in node.args: print_ast(arg, indent + 1)
    elif isinstance(node, FunctionDef):
        print(f"{pfx}FunctionDef: {node.name}({', '.join(node.params)})")
        for stmt in node.body: print_ast(stmt, indent + 1)
    elif isinstance(node, IfStatement):
        print(f"{pfx}If:"); print_ast(node.condition, indent + 2)
        print(f"{pfx}  then:"); [print_ast(s, indent + 2) for s in node.then_body]
        for cond, body in node.elif_clauses: print(f"{pfx}  elif:"); print_ast(cond, indent + 2); [print_ast(s, indent + 2) for s in body]
        if node.else_body: print(f"{pfx}  else:"); [print_ast(s, indent + 2) for s in node.else_body]
    elif isinstance(node, ForLoop):
        print(f"{pfx}For: {node.var}"); print_ast(node.iterable, indent + 2); print(f"{pfx}  body:"); [print_ast(s, indent + 2) for s in node.body]
    elif isinstance(node, WhileLoop):
        print(f"{pfx}While:"); print_ast(node.condition, indent + 2); print(f"{pfx}  body:"); [print_ast(s, indent + 2) for s in node.body]
    elif isinstance(node, ReturnStatement):
        print(f"{pfx}Return:"); print_ast(node.value, indent + 1) if node.value else None
    elif isinstance(node, PrintStatement): print(f"{pfx}Print:"); print_ast(node.value, indent + 1)
    elif isinstance(node, AssertStatement):
        print(f"{pfx}Assert:"); print_ast(node.left, indent + 1)
        if node.right: print(f"{pfx}  {node.operator}"); print_ast(node.right, indent + 1)
    elif isinstance(node, TestBlock): print(f"{pfx}Test: {node.name or ''}"); [print_ast(s, indent + 1) for s in node.body]
    elif isinstance(node, VueComponent):
        print(f"{pfx}VueComponent: {node.name}")
        for k, v in node.properties.items(): print(f"{pfx}  {k}:"); print_ast(v, indent + 2)
    # OOP and Anonymous Functions
    elif isinstance(node, Block):
        print(f"{pfx}Block:")
        for stmt in node.statements: print_ast(stmt, indent + 1)
    elif isinstance(node, AnonymousFuncDef):
        print(f"{pfx}AnonymousFuncDef: &{node.name}({', '.join(node.params)})")
        for stmt in node.body: print_ast(stmt, indent + 1)
    elif isinstance(node, ClassDef):
        print(f"{pfx}Class: {node.name}" + (f" extends {node.extends}" if node.extends else ""))
        if node.properties:
            print(f"{pfx}  properties:")
            for k, v in node.properties.items(): print(f"{pfx}    {k}:"); print_ast(v, indent + 4) if v else print(f"{pfx}    {k}: None")
        if node.methods:
            print(f"{pfx}  methods:")
            for k, v in node.methods.items(): print_ast(v, indent + 4)
    elif isinstance(node, MethodDef):
        print(f"{pfx}MethodDef: {node.name}({', '.join(node.params)})")
        for stmt in node.body: print_ast(stmt, indent + 1)
    elif isinstance(node, PropertyDef):
        print(f"{pfx}Property: {node.name}")
        if node.value: print_ast(node.value, indent + 1)
    elif isinstance(node, MethodCall):
        print(f"{pfx}MethodCall: .{node.method}")
        print_ast(node.obj, indent + 1)
        if node.args:
            print(f"{pfx}  args:")
            for arg in node.args: print_ast(arg, indent + 2)
    elif isinstance(node, Token): print(f"{pfx}Token: {node.type} = {node.value!r}")
    else: print(f"{pfx}{type(node).__name__}: {node}")


if __name__ == '__main__':
    test_code = '''
$integer = 42
$name = "Alice"
@numbers = [1, 2, 3, 4, 5]
%person = {name: "John", age: 30}

def greet($name):
    return "Hello, " + $name + "!"

$greeter = &greet
print($greeter("World"))
print("Integer: " + str($integer))
print("Person name: " + %person["name"])

if $integer > 10:
    print("Large")
else:
    print("Small")

for $i in @numbers:
    print($i)
'''
    parser = PyrlLarkParser(debug=True)
    ast = parser.parse(test_code)
    print_ast(ast)