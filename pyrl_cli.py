#!/usr/bin/env python3
"""
Pyrl CLI - Command Line Interface for the Pyrl Language
A hybrid Python-Perl inspired language interpreter.

Generated by GLN-5 model from z.ai

Usage:
    pyrl                    - Start interactive REPL
    pyrl <file.pyrl>        - Execute a Pyrl file
    pyrl -c "code"          - Execute code from string
    pyrl -p <file.pyrl>     - Parse file and show AST
    pyrl --version          - Show version
    pyrl --help             - Show help
"""
import argparse
import sys
import os
import re
from pathlib import Path

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent))

from src.core.vm import PyrlVM, PyrlRuntimeError
from src.core.lark_parser import print_ast as lark_print_ast, PyrlLarkParser
from src.core.exceptions import PyrlError


__version__ = "2.0.0"
__author__ = "Pyrl Team"


class PyrlCLI:
    """Command Line Interface for Pyrl."""

    def __init__(self, debug: bool = False):
        self.debug = debug
        self.vm = PyrlVM(debug=debug)
        self.env = self.vm.env
        if debug:
            print("\033[90mUsing Lark-based parser with debug mode\033[0m")

    def _format_error_type(self, error_type: str) -> str:
        """Format error type with spaces (e.g., 'PyrlRuntimeError' -> 'PYRL RUNTIME ERROR')."""
        formatted = re.sub(r'(?<!^)(?=[A-Z])', ' ', error_type)
        return formatted.upper()

    def _print_debug_error(self, error_type: str, error: Exception) -> None:
        """Print detailed debug information for ANY error."""
        if self.debug:
            import traceback
            print(f"\n\033[91m{'='*60}\033[0m", file=sys.stderr)
            print(f"\033[91m{self._format_error_type(error_type)}\033[0m", file=sys.stderr)
            print(f"\033[91m{'='*60}\033[0m", file=sys.stderr)
            print(f"\033[93mMessage:\033[0m {error}", file=sys.stderr)
            print(f"\033[93mType:\033[0m {type(error).__name__}", file=sys.stderr)
            if hasattr(error, '__traceback__') and error.__traceback__:
                print(f"\033[93mTraceback:\033[0m", file=sys.stderr)
                traceback.print_exception(type(error), error, error.__traceback__, file=sys.stderr)
            print(f"\033[91m{'='*60}\033[0m\n", file=sys.stderr)
        else:
            print(f"\033[91m{self._format_error_type(error_type)}\033[0m {error}")

    def run_repl(self) -> None:
        """Start interactive REPL session."""
        self._print_banner()

        while True:
            try:
                lines = self._read_multiline()
                if lines is None:
                    continue

                source = "\n".join(lines)
                if not source.strip():
                    continue

                if self._handle_special_command(source.strip()):
                    continue

                result = self.vm.run(source)
                if result is not None:
                    self._print_result(result)

            except KeyboardInterrupt:
                print("\n\nInterrupted. Press Ctrl+C again to exit or type 'exit' to quit.")

            except PyrlRuntimeError as e:
                self._print_debug_error("Runtime Error", e)

            except SyntaxError as e:
                print(str(e), file=sys.stderr)

            except PyrlError as e:
                self._print_debug_error("Pyrl Error", e)

            except Exception as e:
                self._print_debug_error("Error", e)

    def _print_banner(self) -> None:
        """Print REPL banner with PYRL logo."""
        banner = f"""
\033[96m╔═══════════════════════════════════════════════════════════════╗
║                                                               ║
║   \033[92m██████╗ ██╗   ██╗ █████╗ ██╗  ██╗\033[96m                           ║
║   \033[92m██╔══██╗██║   ██║██╔══██╗██║ ██╔╝\033[96m                           ║
║   \033[92m██████╔╝██║   ██║███████║█████╔╝ \033[96m                           ║
║   \033[92m██╔══██╗██║   ██║██╔══██║██╔═██╗ \033[96m                           ║
║   \033[92m██████╔╝╚██████╔╝██║  ██║██║  ██╗\033[96m                           ║
║   \033[92m╚═════╝  ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝\033[96m                           ║
║                                                               ║
║   \033[93mHybrid Python-Perl Language v{__version__}\033[96m              ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝\033[0m
"""
        print(banner)
        print("Type '\033[93mhelp\033[0m' for help, '\033[93mexit\033[0m' to quit")
        print("─" * 63)

    def _read_multiline(self) -> list:
        lines = []
        prompt = "\033[92mpyrl>\033[0m "
        while True:
            try:
                line = input(prompt)
                if lines and not line.strip():
                    break
                if lines and not self._needs_continuation(lines[-1]) and not line.startswith((' ', '\t')):
                    lines.append(line)
                    break
                lines.append(line)
                if not self._needs_continuation(line):
                    break
                prompt = "\033[94m....>\033[0m "
            except EOFError:
                return lines if lines else None
            except KeyboardInterrupt:
                print()
                return None
        return lines if lines else None

    def _needs_continuation(self, line: str) -> bool:
        line = line.rstrip()
        if not line:
            return False
        if line.endswith(':'):
            return True
        brackets = {'(': ')', '[': ']', '{': '}'}
        stack = []
        in_string = False
        string_char = None
        for char in line:
            if in_string:
                if char == string_char:
                    in_string = False
            elif char in '"\'':
                in_string = True
                string_char = char
            elif char in brackets:
                stack.append(brackets[char])
            elif char in brackets.values():
                if stack and stack[-1] == char:
                    stack.pop()
        return len(stack) > 0

    def _handle_special_command(self, cmd: str) -> bool:
        if cmd in ('exit', 'quit', 'q'):
            print("\n\033[93mGoodbye!\033[0m")
            sys.exit(0)
        if cmd == 'help':
            self._print_help()
            return True
        if cmd == 'vars':
            self._print_variables()
            return True
        if cmd == 'reset':
            self.vm.reset()
            print("\033[93mVM reset.\033[0m")
            return True
        if cmd == 'version':
            print(f"Pyrl v{__version__}")
            return True
        if cmd.startswith('load '):
            filepath = cmd[5:].strip()
            self._load_file(filepath)
            return True
        return False

    def _print_help(self) -> None:
        help_text = """
\033[96m╔════════════════════════════════════════════════════════════════╗
║                        \033[93mPYRL HELP\033[96m                           ║
╚════════════════════════════════════════════════════════════════╝\033[0m

\033[93mVariables (Sigils):\033[0m
    $name   - Scalar (single value)
    @array  - Array (list)
    %hash   - Hash/dictionary
    &func   - Function reference

\033[93mAnonymous Functions (v2.0):\033[0m
    &name($params) = { body }
    &double($x) = { return $x * 2 }

\033[93mClasses (v2.0):\033[0m
    class Name {
        prop name = value
        init($args) = { body }
        method name() = { body }
    }

\033[93mREPL Commands:\033[0m
    help     - Show this help
    vars     - Show all variables
    reset    - Reset VM state
    version  - Show version
    load <file> - Load and execute file
    exit     - Exit REPL

\033[93mDebugging:\033[0m
    Run with --debug flag for detailed error messages
"""
        print(help_text)

    def _print_variables(self) -> None:
        variables = self.vm.get_globals()
        if not variables:
            print("\033[90mNo variables defined.\033[0m")
            return
        print("\n\033[93mVariables:\033[0m")
        print("─" * 40)
        for name, value in sorted(variables.items()):
            # Skip builtins and internal variables
            if name.startswith('_') or name in ('True', 'False', 'None', 'PI', 'E', 'INF', 'NAN'):
                continue

            # Determine sigil based on name prefix or value type
            if name.startswith('$'):
                sigil = ''
                display_name = name[1:]
            elif name.startswith('@'):
                sigil = '';
                display_name = name[1:]
            elif name.startswith('%'):
                sigil = ''
                display_name = name[1:]
            elif name.startswith('&'):
                sigil = ''
                display_name = name[1:]
            elif isinstance(value, list):
                sigil = '@'
                display_name = name
            elif isinstance(value, dict):
                sigil = '%'
                display_name = name
            elif callable(value):
                sigil = '&'
                display_name = name
            else:
                sigil = '$'
                display_name = name

            if isinstance(value, (list, dict)):
                value_str = str(value)
                if len(value_str) > 50:
                    value_str = value_str[:47] + "..."
            elif callable(value):
                value_str = f"<function>"
            else:
                value_str = repr(value)
            print(f"  {sigil}\033[92m{display_name}\033[0m = {value_str}")
        print()

    def _print_result(self, result) -> None:
        if isinstance(result, bool):
            print(f"\033[93m{result}\033[0m")
        elif isinstance(result, (int, float)):
            print(f"\033[96m{result}\033[0m")
        elif isinstance(result, str):
            print(f"\033[93m'{result}'\033[0m")
        elif isinstance(result, list):
            print(f"\033[94m{result}\033[0m")
        elif isinstance(result, dict):
            print(f"\033[95m{result}\033[0m")
        else:
            print(f"\033[90m{result}\033[0m")

    def _load_file(self, filepath: str) -> None:
        try:
            path = Path(filepath)
            if not path.exists():
                print(f"\033[91mError: File not found: {filepath}\033[0m")
                return
            print(f"\033[90mLoading {filepath}...\033[0m")
            result = self.vm.run_file(str(path))
            print(f"\033[92mFile loaded successfully.\033[0m")
            if result is not None:
                self._print_result(result)
        except SyntaxError as e:
            if self.debug:
                self._print_debug_error("SyntaxError", e)
            else:
                print(str(e), file=sys.stderr)
        except Exception as e:
            if self.debug:
                self._print_debug_error(type(e).__name__, e)
            else:
                print(f"\033[91mError loading file: {e}\033[0m")

    def run_file(self, filepath: str) -> int:
        try:
            path = Path(filepath)
            if not path.exists():
                print(f"Error: File not found: {filepath}", file=sys.stderr)
                return 1
            result = self.vm.run_file(str(path))
            return 0
        except SyntaxError as e:
            if self.debug:
                self._print_debug_error("SyntaxError", e)
            else:
                print(str(e), file=sys.stderr)
            return 1
        except PyrlRuntimeError as e:
            if self.debug:
                self._print_debug_error("PyrlRuntimeError", e)
            else:
                print(f"Runtime Error: {e}", file=sys.stderr)
            return 1
        except PyrlError as e:
            if self.debug:
                self._print_debug_error("PyrlError", e)
            else:
                print(f"Error: {e}", file=sys.stderr)
            return 1
        except Exception as e:
            self._print_debug_error(type(e).__name__, e)
            return 1

    def run_code(self, code: str) -> int:
        try:
            result = self.vm.run(code)
            if result is not None:
                print(result)
            return 0
        except SyntaxError as e:
            if self.debug:
                self._print_debug_error("SyntaxError", e)
            else:
                print(str(e), file=sys.stderr)
            return 1
        except PyrlRuntimeError as e:
            if self.debug:
                self._print_debug_error("PyrlRuntimeError", e)
            else:
                print(f"Runtime Error: {e}", file=sys.stderr)
            return 1
        except PyrlError as e:
            if self.debug:
                self._print_debug_error("PyrlError", e)
            else:
                print(f"Error: {e}", file=sys.stderr)
            return 1
        except Exception as e:
            self._print_debug_error(type(e).__name__, e)
            return 1

    def parse_file(self, filepath: str) -> int:
        try:
            path = Path(filepath)
            if not path.exists():
                print(f"Error: File not found: {filepath}", file=sys.stderr)
                return 1
            source = path.read_text()

            parser = PyrlLarkParser(debug=self.debug)
            ast = parser.parse(source)

            print(f"\n\033[96mAST from {filepath}:\033[0m")
            print("─" * 60)
            lark_print_ast(ast)
            return 0
        except SyntaxError as e:
            if self.debug:
                self._print_debug_error("SyntaxError", e)
            else:
                print(str(e), file=sys.stderr)
            return 1
        except Exception as e:
            self._print_debug_error(type(e).__name__, e)
            return 1


def create_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog='pyrl',
        description='Pyrl Language Interpreter - A hybrid Python-Perl language',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    pyrl                      Start interactive REPL
    pyrl script.pyrl          Execute a script file
    pyrl -c '$x = 10'         Execute code from command line
    pyrl -p script.pyrl       Show AST

New in v2.0:
    - Anonymous functions: &name($x) = { return $x * 2 }
    - Classes with methods and properties
    - Block syntax: { stmt; stmt }

For more information, visit: https://github.com/pyrl-lang/pyrl
"""
    )
    parser.add_argument('file', nargs='?', help='Pyrl script file to execute')
    parser.add_argument('-c', '--code', metavar='CODE', help='Execute code from command line')
    parser.add_argument('-p', '--parse', action='store_true', help='Parse file and show AST')
    parser.add_argument('-d', '--debug', action='store_true', help='Enable debug mode')
    parser.add_argument('-v', '--version', action='version', version=f'Pyrl {__version__}')
    parser.add_argument('--no-color', action='store_true', help='Disable colored output')
    return parser


def main() -> int:
    parser = create_parser()
    args = parser.parse_args()

    if args.no_color:
        os.environ['NO_COLOR'] = '1'

    cli = PyrlCLI(debug=args.debug)

    if args.code:
        return cli.run_code(args.code)
    if args.parse and args.file:
        return cli.parse_file(args.file)
    if args.file:
        return cli.run_file(args.file)

    try:
        cli.run_repl()
        return 0
    except KeyboardInterrupt:
        print("\n\nGoodbye!")
        return 0


if __name__ == '__main__':
    sys.exit(main())
